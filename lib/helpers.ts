import BigNumber from 'bignumber.js';
import { ethers } from 'hardhat';

import type { HardhatRuntimeEnvironment } from 'hardhat/types';

/**
 * Overwrites build artifacts to inject generated bytecode
 *
 * @param hre - hardhat runtime environment
 * @param contractName - contract name to overwrite
 * @param bytecode - bytecode to inject
 * @returns promise for completion
 */
export async function overwriteArtifact(
  hre: HardhatRuntimeEnvironment,
  contractName: string,
  bytecode: string,
): Promise<void> {
  const artifact = await hre.artifacts.readArtifact(contractName);
  artifact.bytecode = bytecode;
  await hre.artifacts.saveArtifactAndDebugFile(artifact);
}

export const SNARK_SCALAR_FIELD =
  21888242871839275222246405745257275088548364400416034343698204186575808495617n;

export function fromHexToDec(hex: string): string {
  if (hex.slice(0, 2) === '0x') {
    return new BigNumber(hex.slice(2).toUpperCase(), 16).toString(10);
  } else {
    return new BigNumber(hex, 16).toString(10);
  }
}

export function fromDecToHex(dec: string, withPrefix: boolean = false): string {
  if (withPrefix) {
    return '0x' + new BigNumber(dec, 10).toString(16);
  } else {
    return new BigNumber(dec, 10).toString(16);
  }
}

export function fromHexToBytes32(hex: string): string {
  if (hex.length <= 64) {
    return '0x' + new Array(64 - hex.length + 1).join(`0`) + hex;
  } else {
    throw new Error('hex string too long');
  }
}

export function generateRandomBytes32Array(length: number): Uint8Array[] {
  const result = [];
  for (let i = 0; i < length; i++) {
    result.push(ethers.utils.randomBytes(32));
  }
  return result;
}

/**
 * Convert typed byte array to bigint
 *
 * @param array - Array to convert
 * @returns bigint
 */
export function arrayToBigInt(array: Uint8Array): bigint {
  // Initialize result as 0
  let result = 0n;

  // Loop through each element in the array
  array.forEach((element) => {
    // Shift result bits left by 1 byte
    result = result << 8n;

    // Add element to result, filling the last bit positions
    result += BigInt(element);
  });
  return result;
}

/**
 * Convert bigint to byte array
 *
 * @param bn - bigint
 * @param length - length of resulting byte array, 0 to return byte length of integer
 * @returns byte array
 */
export function bigIntToArray(bn: bigint, length: number): Uint8Array {
  // Convert bigint to hex string
  let hex = BigInt(bn).toString(16);

  // If hex is odd length then add leading zero
  if (hex.length % 2) hex = `0${hex}`;

  // Split into groups of 2 to create hex array
  const hexArray = hex.match(/.{2}/g) ?? [];

  // Convert hex array to uint8 byte array
  const byteArray = new Uint8Array(hexArray.map((byte) => parseInt(byte, 16)));

  return arrayToByteLength(byteArray, length);
}

// this function convert the proof output from snarkjs to parameter format for onchain solidity verifier
export function processProof(proof: any) {
  const a = proof.pi_a.slice(0, 2).map((x) => fromDecToHex(x, true));
  // for some reason the order of coordinate is reverse
  const b = [
    [proof.pi_b[0][1], proof.pi_b[0][0]].map((x) => fromDecToHex(x, true)),
    [proof.pi_b[1][1], proof.pi_b[1][0]].map((x) => fromDecToHex(x, true)),
  ];

  const c = proof.pi_c.slice(0, 2).map((x) => fromDecToHex(x, true));
  return [a, b, c];
}

// this function processes the public inputs
export function processPublicSignals(publicSignals: any) {
  return publicSignals.map((x) => fromDecToHex(x, true));
}

export const zkCertificateFieldOrder = [
  'surname',
  'forename',
  'middlename',
  'yearOfBirth',
  'monthOfBirth',
  'dayOfBirth',
  'verificationLevel',
  'expirationDate',
  'holderCommitment',
  'providerSignature',
  'randomSalt',
  'streetAndNumber',
  'postcode',
  'town',
  'region',
  'country',
];
